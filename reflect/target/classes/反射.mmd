Mind Map generated by NB MindMap plugin   
> __version__=`1.1`,showJumps=`true`
---

# 反射

## 由于反射的存在<br/>属性名可以和方法名一样

### Class 也是一个类<br/>也继承了Object

### Class这个类不是NEW出来的<br/>而是系统创建的

### 无论是new 还是forName<br/>还是是\.class<br/>都是通过loadCLass记载进来的

#### 堆里面存在一份类<br/>无论是相同的类NEW多少次

#### 所以泛型擦除也是这样的

#### 通过Class字节码对象获取一套对象

#### 生成CLass对象的同时也生成类对象\(已经算一种数据的存储结构\)<br/>的元素据（模板

### 编译阶段  forName\(\)<br/>字节码    xx\.class\(\)<br/>已经有实例化了 对象\.class\(\)<br/>借用类加载器实现

#### 类加载器

##### //套用类加载器获取这个字节码对象<br/>ClassLoader classLoader = ccc\.class\.getClassLoader\(\);<br/>        //通过这个类加载器生成对象<br/>        Class\<?\> aClass = classLoader\.loadClass\("del\.ccc"\);<br/>        System\.out\.println\( aClass\);

### int\.class<br/>Integer\.Type

## 反射允许 使用Reflectrion<br/>API去获取字节码对象身上的属性

### 加载完类之后，就在堆里面的常量区生成一个Class类<br/>这个类包含了类的所有结构

### 而通过这个CLass类可以看到加载类的所有结构就叫反射，<br/>是通过这个字节码类去反射出来的那些属性

## 反射机制完成

### 运行时判断一个对象所属的类

#### java\.lang\.reflect\.Class

##### 在堆里面的字节码对象

##### 知道类名<br/>xx\.class

##### 不知道类名<br/>Class\.forName\("类名"\)

### 运行时构造任意一个对象

#### java\.lang\.reflect\.Constact

##### 公共属性

###### 获取公共单个构造器

####### getConstructor

####### 里面有属性<br/>xx\.class

###### 获取所有公共构造器

####### getConstructors<br/>

####### 里面有属性<br/>xx\.class

##### 所有属性

###### 单个任意构造器

####### getDeclaredConstructor

####### 记得给破解权限

####### 无用的参数给null

###### 所有任意构造器

####### getDeclaredConstructors<br/>

####### 记得给破解

### 得到成员属性

#### java\.lang\.reflect\.field

##### 只能获取共有属性

###### getField<br/>只能获取单个属性

###### Field\[\]<br/>可以获取所有的public属性<br/>获取所有属性<br/>包括父类的

##### 获取所有属性

###### getDeclaredField<br/>获取单个属性

####### 无论是GET<br/>还是SET<br/>都要设置<br/>SETACCESSIBLE

###### getDeclaredField\[\]<br/>获取所有属性<br/>包括父类的

####### 无论是GET<br/>还是SET<br/>都要设置<br/>SETACCESSIBLE

####### 其他的内容<br/>还是跟上面的一样

### 反射中使用的宿主一定要一致<br/>获取单个元素无法获取父类<br/>但是获取数组可以获取父类的属性或者方法或者构造器

### 得到成员方法

#### java\.lang\.reflect\.method

##### 如果有xx类型的参数通过xx类型\.class<br/>去填就能获取

##### 只能读取，无法修改内部

##### 获取单个方法

###### getMethod<br/>获取单个共有方法

####### 如果是静态方法，<br/>在宿主位置给null

####### 参数位置<br/>给一个具体对象

###### getMethods\(\)<br/>获取所有公共方法<br/>包括继承的方法

####### 如果是静态方法。<br/>在宿主位置给null

####### 参数位置

##### 获取保护和私有方法

###### getDeclaredMethod<br/>获取单个方法

####### 方法同上

####### 记得给破解权限

###### getDeclaredMethods<br/>获取所有方法

### 生成动态代理

#### 静态加载

##### 编译时候（就是写代码<br/>加载，如果没有就报错

#### 动态加载

##### 不在编译（写代码<br/>期间）加载类<br/>只有执行到该语句的时候才去寻找类<br/>并且加载

###### Class\.forNmae\("SB"\)<br/>明明没有SB这个类<br/>

#### 类被加载的时机

##### 子类被加载<br/>子类首先要实例化父类

##### 被实例化<br/>自己实例化自己

##### 被反射<br/>被动调用类加载器

##### 静态方法的调用<br/>类调用静态方法从方法区自动加载类

#### 类加载的过程

##### 加载

###### JVM加载字节码文件

##### 链接

###### 进行安全检查

###### 搜集所有静态变量<br/>并进行默认值的赋值

####### 这里会先给空间<br/>在给默认值

##### 初始化

###### 收集所有的静态系列的东西，<br/>进行初始化（自己给定的值

###### 如果有多个THREADer进行初始化，<br/>JVM会加锁，其他的会阻塞，只有一个可以过
